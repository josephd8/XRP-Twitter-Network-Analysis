---
title: '#XRP Twitter Network Analysis'
author: "Joseph Cook"
date: "October 22, 2019"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, include = FALSE)
```

```{r libraries, include=FALSE}
library(vosonSML)
library(sna)
library(igraph)
library(network)
library(tidyverse)
```

# Data Collection

```{r twitter_auth}
# keys <- list(appName = "XRP", 
#              apiKey = Sys.getenv("twitter_api_key"), 
#              apiSecret = Sys.getenv("twitter_api_secret"), 
#              accessToken = Sys.getenv("twitter_access_token"),
#              accessTokenSecret = Sys.getenv("twitter_access_secret"))
# 
# twitterAuth <- Authenticate("twitter", appName = keys$appName, apiKey = keys$apiKey, 
#                             apiSecret = keys$apiSecret, accessToken = keys$accessToken,
#                             accessTokenSecret = keys$accessTokenSecret)

#twitterAuth <- readRDS(".twitter_auth")
```

```{r twitter_search}
#twittersearchTerm <- c('#XRP')

# twitterData <- twitterAuth %>%
#   Collect(searchTerm = twittersearchTerm, searchType = "recent", numTweets = 1100, 
#           includeRetweets = TRUE , retryOnRateLimit = TRUE, writeToFile = FALSE, 
#           verbose = TRUE)

# View(twitterData)
load("xrp_twitter_network.Rdata")
```

```{r actor_network}
# actorNetwork <- twitterData %>% Create("actor")
# actorGraph <- actorNetwork$graph
```

```{r clean_edges}
edge_cleanup <- function(graph = actorGraph){
  library(igraph)
  df <- get.data.frame(actorGraph)
  names_list <- data.frame('name' = as.character(V(actorGraph)$name),
                           'label' = as.character(V(actorGraph)$label))
  df$from <- sapply(df$from, function(x) names_list$label[match(x,names_list$name)] %>% as.character())
  df$to <- sapply(df$to, function(x) names_list$label[match(x,names_list$name)] %>% as.character())
  nodes <- data.frame(sort(unique(c(df$from,df$to))))
  links <- df[,c('from','to')]
  net <- graph.data.frame(links, nodes, directed=T)
  E(net)$weight <- 1
  net <- igraph::simplify(net,edge.attr.comb="sum")
  return(net)
}

# actorGraph <- edge_cleanup()
```

```{r basic_network_stats}
# check if the network is directed or undirected
is.directed(actorGraph)

########################
# Check the criterion
########################
# check the size of the network
vcount(actorGraph) ## the number of nodes/actors/users
ecount(actorGraph) ## the number of edges

possible_links <- vcount(actorGraph) * (vcount(actorGraph) - 1)

# calculate the density of the network
graph.density(actorGraph)
```

## XRP Network

XRP is a crypto-asset native to the XRP ledger. It is infamously tied to the company, Ripple, who owns a majority of XRP at the moment even though the ledger is open-source technology. Ripple and the larger XRP community have been making great strides at positioning XRP as the ultimate "bridge currency" for all other two-pair currency exchanges. Their vision is the "Internet of Value" where we will be able to send money/value back and forth similar to the way we share data on the internet. I am intrigued by the future of XRP and the XRP ledger, thus I wanted to analyze the #XRP hashtag to see if I could learn about the social network on Twitter.

I chose the #XRP hashtag as I have seen it more often than any other related hashtag. While this is already a nascent industry with only a small comparative following I felt it was important to use the broadest, most well recognized hashtag. Also, whenever there are arguments about the advantages of XRP versus, say Bitcoin (BTC), those tweets usually involve the #XRP hashtag, so I am curious to see if I will capture any of that.

Mostly, I am hoping to see if I can identify the major leaders of the "XRP Army" (a nickname for the XRP fanbase), as well as the most dedicated soldiers. I imagine that leaders will have some form of high degree-centrality, and top soliders/followers will have a high betweeness measure. Also, I am interested in the overall composition of the network and how disjointed or connected it is.

## Basic Network Statistics

The graph is `r if(is.directed(actorGraph)) paste0("directed") else paste0("undirected")`.  
There are `r vcount(actorGraph)` nodes and `r ecount(actorGraph)` edges in this network.  
There are 683,102 possible links in the network.  
The density of this network is `r graph.density(actorGraph)`.  

## Data Considerations

If I wanted to look at a broader crypto network, I would want to use the #crypto hashtag. If I wanted to look at the other side of most crypto arguments (compared to the XRP Army), I would want to look at the #BTC (bitcoin) hashtag. By using the #XRP hashtag, I am boxing myself into somewhat of a narrow network, most-likely with similar nodes. Given the purpose of this analysis, this is ok.

# Network Visualization

```{r load_network_data}
# load("xrp_twitter_network.Rdata")
```

## Full Network

### Force-directed Layout Algorithm

```{r full_network_graph, include = TRUE}
# Plot a graph
actorGraph %>% 
  plot(.,
       layout = layout_with_fr(.),
       edge.arrow.size = .3,
       vertex.size = 7,
       vertex.color = 'red',
       vertex.label = NA, ## uncomment here if you don't want to display labels
       vertex.label.cex = .5,
       vertex.label.color = 'black')
```

```{r full_components}
# Calculate the number of components in the graph
comp <- components(actorGraph)
comp$csize
comp$no
```

The first observation I see is the giant component to the lower left of the graph with many smaller (and in many cases isolated) components in a moon shape around the top right of the graph. 

Digging deeper, there are `r comp$no` different components (sizes below). The giant component contains 555 nodes, while `r length(which(comp$no == 1))` of the components are isolated and `r length(which(comp$no <= 3))` of the components contain 3 or less nodes.

`r comp$csize`

Even within the giant component though, there seems to be a few saturated groups similar to the 3 components of 12-17 nodes. My hypothesis is that there are roughly ~10 main conversations going on, likely started by major movers in the XRP space, and these conversations are then linked by a few nodes who are active across the whole space (high betweenness).


## Giant Component

### Force-directed Layout Algorithm

```{r giant_graph, include=TRUE}
# Take out a giant component from the graph
giantGraph <- actorGraph %>% 
  induced.subgraph(., which(comp$membership == which.max(comp$csize)))
#vcount(giantGraph) ## the number of nodes/actors/users
#ecount(giantGraph) ## the number of edges

# Plot a graph of giant component. (.) in layout gets the last data
giantGraph %>% 
  plot(.,
       layout = layout_with_fr(.),
       edge.arrow.size = .3,
       vertex.size = 4,
       vertex.color = 'red',
       vertex.label = NA,
       vertex.label.cex = .5,
       vertex.label.color = 'black')
```

After separating out the giant component from the full network I was able to better visualize my hypothesis of multiple main conversations/head nodes. From this visualization I am able to account for ~10 "groups" centered around a single node. 

This also gives better insight into the nodes on the periphery. There are multiple "spikes" coming from out of the center of the giant component. Interestingly, the arrows seem to be pointing outward as you move out for the most part. This seems to support my other hypthesis that there are some nodes with high betweeness that participate not only in the main conversations, but even connect and interact with non-influential nodes, thereby connecting them to the giant component.

### Simulated Annealing Algorithm + Node Weights by Degree

```{r giant_graph_2, include=TRUE}
# Experiment with other layouts by replacing with your choice of layout, then running a plot function above.
# layout = layout_with_...(.)
# For that, you can pick one of the options below.
# layout_with_dh(.) # Davidson and Harel
# layout_with_drl(.) # Force-directed
# layout_with_kk(.) # Spring

# You can play with the vertex sizes and/or edge sizes to get a better vizualization for the graphs above

V(giantGraph)$vertex_degree <-  degree(giantGraph)

giantGraph %>%
  plot(.,
       layout = layout_with_dh(.),
       edge.arrow.size = .1,
       edge.curved = TRUE,
       vertex.size = V(giantGraph)$vertex_degree,
       vertex.color = grDevices::adjustcolor("#63B8FF", alpha=0.5),
       vertex.label = NA)

```

I used the simulated annealing layout algorithm (layout_with_dh) for this visualization because it successfuly separating out the nodes with high degree in a way that I could visualize them easier. I also sized each node by it's degree, which allows us to see clearly that there are ~10 high-degree nodes in the giant component of this network. Also, there are ~50 nodes that have a degree high enough to substantiate on the visualization. Again, this visualization confirms my hypothesis of a few major nodes where the activities in the network are centered, with a slightly larger number of nodes acting as connectors for the network.

# Individual Network Properties

```{r igraph_to_sna}
sna_graph <- igraph::get.adjacency(giantGraph, sparse=FALSE) %>% network::as.network.matrix()
detach('package:igraph')
```

```{r compute_centralities}
# Compute centralities based on 'network' package
# Calculate in-degree centrality
degree(sna_graph, cmode = 'indegree')
# Store the information
centralities <- data.frame('node_name' = as.character(network.vertex.names(sna_graph)),
                           'in_degree' = degree(sna_graph, cmode = 'indegree'))

# Calculate out-degree centrality and store it in the data.frame called 'centralities'
centralities$out_degree <- degree(sna_graph, cmode = 'outdegree')

# Calculate betweenness centrality and store it in the data.frame called 'centralities'
centralities$betweenness <- betweenness(sna_graph)

# Calculate closeness centrality and store it in the data.frame called 'centralities'
centralities$incloseness <- igraph::closeness(giantGraph, mode = 'in')
centralities$outcloseness <- igraph::closeness(giantGraph, mode = 'out')

# Calculate eigenvector centrality and store it in the data.frame called 'centralities'
centralities$eigen <- evcent(sna_graph)

# Calculate Burt's network constraint and store it in the data.frame called 'centralities'
# using 'igraph' because 'sna' doesn't have the function
centralities$netconstraint <- igraph::constraint(giantGraph)

# Calculate authority and store it in the data.frame called 'centralities'
# using 'igraph' because 'sna' doesn't have the function
# 'igraph::' allows calling for any igraph function without loading the package
centralities$authority <- igraph::authority_score(giantGraph, scale = TRUE)$`vector`

# Calculate hub and store it in the data.frame called 'centralities'
# using 'igraph' because 'sna' doesn't have the function
centralities$hub <- igraph::hub_score(giantGraph, scale = TRUE)$`vector`

#View(centralities)
```

## Target Diagram - Betweenness

```{r target_diagram}
# Produce a target diagram, centering by one of your choice of centralities (e.g., betweenness)
# WARNING - below might take some time to produce it 
# if you're running other tasks on your computer, make sure that your CPU has some space to run this plot
# sna::gplot.target(sna_graph, centralities$betweenness,
#                   displaylabels = FALSE, ## if you don't want to see labels, replace TRUE with FALSE
#                   label.cex=.5,
#                   main="Betweenness",
#                   # circ.lab = TRUE,
#                   circ.col="skyblue",
#                   usearrows = TRUE,
#                   # vertex.col=c("blue", rep("red", 32), "yellow"),
#                   edge.col="darkgray")

```

## Centrality Ranks

```{r create_node_table, include=TRUE}
# For creating the table in part III you can use the following, replace eigen with other centrality measures that you want

ranks <- data.frame("Rank" = 1:10)

ranks <- ranks %>% 
  mutate("In-degree" = centralities %>% arrange(desc(in_degree)) %>% head(10) %>% mutate("In-degree" = paste0(node_name, " (", round(in_degree,3), ")")) %>% pull("In-degree"),
         "Out-degree" = centralities %>% arrange(desc(out_degree)) %>% head(10) %>% mutate("Out-degree" = paste0(node_name, " (", round(out_degree,3), ")")) %>% pull("Out-degree"),
         "Betweenness" = centralities %>% arrange(desc(betweenness)) %>% head(10) %>% mutate("Betweenness" = paste0(node_name, " (", round(betweenness,3), ")")) %>% pull("Betweenness"),
         "In-closeness" = centralities %>% arrange(desc(incloseness)) %>% head(10) %>% mutate("In-closeness" = paste0(node_name, " (", round(incloseness,8), ")")) %>% pull("In-closeness"),
         "Out-closeness" = centralities %>% arrange(desc(outcloseness)) %>% head(10) %>% mutate("Out-closeness" = paste0(node_name, " (", round(outcloseness,8), ")")) %>% pull("Out-closeness"),
         "Eigen" = centralities %>% arrange(desc(eigen)) %>% head(10) %>% mutate("Eigen" = paste0(node_name, " (", round(eigen,3), ")")) %>% pull("Eigen"),
         "Net-constraint" = centralities %>% arrange(desc(netconstraint)) %>% head(10) %>% mutate("Net-constraint" = paste0(node_name, " (", round(netconstraint,3), ")")) %>% pull("Net-constraint"),
         "Authority" = centralities %>% arrange(desc(authority)) %>% head(10) %>% mutate("Authority" = paste0(node_name, " (", round(authority,3), ")")) %>% pull("Authority"),
         "Hub" = centralities %>% arrange(desc(hub)) %>% head(10) %>% mutate("Hub" = paste0(node_name, " (", round(hub,3), ")")) %>% pull("Hub"))

knitr::kable(ranks[,c(1:5)])
```

```{r node_table_2, include=TRUE}
knitr::kable(ranks[,c(1,6:9)])
```

```{r node_table_3, include=TRUE}
knitr::kable(ranks[,c(1,10)])
```

## Discusson on Individual Network Properties

##### Centrality Measures

**In-degree:** The number of directional links to the node. In this scenario, it would be the number of nodes who replied or retweeted the node. A high in-degree signifies a central figure in the XRP community because the node is trusted enough to be responded to and retweeted.    
**Out-degree:**  The number of directional links to other nodes. In this scenario, it would be the number of people this node replied to or retweeted. A high out-degree singals a figure who is active in the space more broadly and participates in more conversations.  
**Betweenness:** The number of geodesic distances that pass through a node. A high betweenness score means the figure is a bridge between main conversations on Twitter. If you want to follow more conversations, follow these nodes.  
**In-closeness:** Closeness measures how close a node is to the rest of the nodes in the network. Specifically, in-closeness corresponds to the ease of which a node can spread information anywhere in the network. In this analysis, a high in-closeness would be a figure who is at the center of the network and has been replied or retweeted in multiple different conversations.  
**Out-closeness:** Out-closeness is the opposite, measuring how easy it is for a node to get information from the outside network. In this analysis, this would be a node that is plugged in to many different nodes in many different conversations.   
**Eigenvector:** A function of a node's neighbors' centralities. A node in this scenario that has a high eigenvector centrality would be someone who is closely related to multiple high-degree nodes, and has some moderate level of degree themselves. These nodes are well integrated into the community.  
**Burt's network constraint:** A measure of the extent to which a node's connections are circular, or connected with each other. Nodes with high constraint have difficulty getting access to new information because of their lack of outside connections. In this analysis, this would be a person that is only involved in one or two conversations and is unaware of outside activity.   
**Authorities & Hubs:** Authorities contain useful information, and Hubs indicate where the autorities can be found. These two metrics are cacluated together. The authority score is proportional to the sum of hub scores pointing to it, while the hub score is proportional to the sum of authority scores it points to. In the XRP network, authorities should be the main sources of information, while hubs should be the main relayers of information.    

##### Centrality in the XRP Network

Looking across the centrality measures for the XRP Network, there are a few that don't seem to be great measures due to the sparse density of the network as a whole: in-closeness, out-closeness, net-constraint, and potentially authorities and hubs. It seems like in-degree, out-degree, betweenness, and eigenvector centrality are the richest measures of centality for this network.

Kevin_Cage_ appears as the third-highest in-degree centrality. This node also appears second-highest in betweenness, and seventh in eigenvector centrality. Across all metrics, this appears to be of the the most central nodes. DigitalNomadInv is ninth in in-degree and first in both out-degree and betweenness. I would characterize Kevin_Cage_ as a highly influential node, and DigitalNomadInv as the highest broker in the network - connecting multiple players throughout. 


# Global Network

1.	(3 points) Briefly describe (a) what k-core is, (b) what insight this k-core decomposition method provides, and (c) how many k’s exist in your network.
2.	(3 points) Visualize your network using k-core decomposition and include the visualization in your report. In a paragraph, discuss your interpretation of the visualization and whether the results of k-core decomposition make sense based on your expectations of the network.
3.	(3 points) Pick one of community detection algorithms. Which community detection algorithm did you choose and why?
4.	(3 points) How many communities have been created? For your network, what might a community of nodes potentially have in common?
5.	(3 points) What is a modularity score? Interpret the modularity score of your results of community detection?
6.	(6 points) Plot the clusters and include the plot image in your report. What information does this layout convey? Are the clusters well-separated, or is there a great deal of overlap? What differences are there between actors in the same cluster and across clusters? Describe the brokers between any components and cliques.  What are common features of these brokers?
7.	(3 points) Present and interpret the in- and out-degree distribution based on your network as well as a log-log plot. Compute and interpret the estimate of the c slope.
8.	(3 points) Present in a plot the observed and simulated values for each average path length and clustering coefficient based on the original network and 1,000 randomly shuffled networks
9.	(3 points) Based on these data would you conclude that the observed network demonstrates small world properties? If so, why? If not, why not?
10.	(10 points) In two or three paragraphs, discuss your major findings of your network based on all the analyses you’ve done in this exercise and also your own additional analysis if necessary. Your answer here will be evaluated based on depth and comprehensiveness. Thus, you’re encouraged to utilize extra information to answer this question. For instance, you can take a look at your original data (i.e., “twitterData,” “youtubeData,” or “redditData” if you work with the provided R code) in R. These data frames include additional user, text, and time information for your network. Similarly, if you need more insights from your network, feel free to run correlation and regression analysis based on your data collection.


```{r save_image}
save.image('xrp_twitter_network.Rdata')
```

